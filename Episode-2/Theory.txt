1. what is npm?
-->  It is a widely-used package manager for JavaScript programming language.
 It allows developers to easily install, manage, and share libraries and dependencies (packages) 
 needed for their web and Node.js applications. 

2. what is parcel or a web pack why do we use it ?
--> Parcel and webpack are both popular JavaScript bundlers used in web development 
to optimize and package assets like JavaScript, CSS, and images for production-ready web applications.

* They help manage dependencies and assets in modern web development.
* They allow you to bundle and optimize your code for production.
* They enable the use of modern JavaScript features that might not be 
  supported in all browsers by default.
* They facilitate a modular approach to code organization, 
  improving maintainability and scalability of projects.

3. what is .parcel-cache?
 --> The .parcel-cache directory is a folder created by the Parcel bundler in your project's 
  root directory. It is used to cache and store intermediate build artifacts, dependencies, 
  and compiled assets to improve build performance. Parcel uses this cache to avoid redundant 
  work during subsequent builds, making the development process faster and more efficient. 
  It helps speed up the bundling process by reusing previously processed data, 
  especially for larger projects or when dealing with complex dependencies.
   
4. what is npx?
--> a command-line tool that comes with Node.js and is used to execute packages from the npm registry

5. what is the diff between dependencies and devdependencies?
--> Dependencies:
* These are the packages that are required for your application to run in a production environment.
* They include libraries and frameworks that your application relies on to function properly.
* Examples include web frameworks, utility libraries, database connectors, etc.
* When someone installs your application (typically a user or another developer), 
  these packages will be installed as well.

DevDependencies:
* These are packages that are only needed for development and testing purposes. 
* They are not required for the application to function in a production environment.
* Examples include testing frameworks, build tools, linters, etc.
* When someone is working on the project, they would need these packages to help with development, 
  but they are not included when the project is deployed or distributed.

6. what is Tree shaking?
--> It refers to the process of eliminating or "shaking off" dead or unused code 
(JavaScript modules or functions) from the final bundled output. 
The goal of tree shaking is to reduce the size of the bundled JavaScript file, 
making it more efficient and faster to load in a web browser.


7. what is hot module replacement?
--> It allows developers to see changes made to their code in real-time without having to 
    manually refresh the entire web page or restart the development server.

8. List down 5 super power of parcel describe any 3?
-->
-> Bundling: 
Parcel bundles your project's JavaScript, CSS, HTML, and other assets into optimized 
and production-ready files. It automatically handles dependencies and ensures that your 
application is efficiently packaged for deployment.

-> Development Server:
 Parcel comes with a built-in development server that makes it easy to preview
 your project during development. It supports features like auto-reloading when you make code changes.

-> Zero Configuration: 
One of Parcel's notable features is its zero-configuration setup.
 You can start using Parcel without complex configuration files, 
 allowing you to focus on writing code instead of build configurations.

->Support for Multiple File Types:
 Parcel supports various file types out of the box, including JavaScript (ES6+),
 CSS (Sass, Less), HTML, and more. It can even handle assets like images and fonts,
 optimizing them as needed.

->Optimizations: 
  Parcel automatically performs optimizations like minification and code splitting to reduce
   the size of your assets and improve load times.

9. what is .gitignore ? what we shuld add or not add in to it?
--> .gitignore is a configuration file used in Git repositories to specify
 which files and directories should be ignored by Git when tracking changes.
 By adding files or patterns to the .gitignore file,
  you can prevent Git from including them in version control, 
  which is particularly useful for files that are generated during the development process, 
  contain sensitive information, or are simply not relevant to the project's history.

Here are some common things to add to a .gitignore file:
Node Modules: 
Ignore the node_modules directory, which contains dependencies installed by npm or Yarn.
These are typically large and can be easily regenerated by running package installation commands.
/node_modules

Build Artifacts: 
Ignore files and directories generated during the build process, such as compiled code, 
transpiled code, or minified files.
/dist
/build
/out

Temporary Files: 
Ignore files generated by text editors or IDEs,
like .DS_Store on macOS, or temporary backup files.
.DS_Store
*~

Environment Files:
 Ignore environment-specific configuration files, especially if they 
 contain sensitive information like API keys or passwords.
.env
.env.local

Logs and Debug Output: 
Ignore log files, debug output, or error logs generated during development.
/logs
*.log

User-Specific Files: 
Ignore files or directories that are specific to individual developers
 or their development environments.
/user-settings
Dependency Lock Files: 
Depending on your project setup, you might want to ignore lock files generated by
 package managers like package-lock.json or yarn.lock.
/package-lock.json
/yarn.lock

IDE and Editor Files: 
Ignore configuration files and directories specific to your IDE or code editor.
.vscode/
.idea/

10. what is the diff between package.json and package.lock.json?
-> package.json:
This file contains metadata about your project and its dependencies.
It specifies which packages your project depends on and their versions.
It's meant for human-readable information and high-level project configuration.
Developers typically edit this file directly to add or update dependencies.
It doesn't lock the exact versions of dependencies, so it allows for some flexibility in versions.

package-lock.json:
This file is automatically generated by npm (Node Package Manager) and is used to lock down 
the specific versions of dependencies.
It ensures that everyone working on the project uses the exact same versions of packages.
It's primarily used to guarantee reproducibility and consistency when building and 
running the project across different environments or by different developers.
Developers generally don't edit this file manually.

In summary, package.json is for high-level project configuration and specifying dependencies,
 while package-lock.json is for ensuring that everyone working on the project uses the same versions 
 of those dependencies, making it a critical tool for maintaining consistency in a Node.js project.

11. what is node_modules ? is it good idea to push that on to git?
-> it's best practice to exclude the node_modules directory from version control 
and rely on your project's package.json and lock file (package-lock.json or yarn.lock) 
to manage and recreate the dependencies when needed. 
This approach promotes a more efficient and secure development workflow.

12. what is dist folder?
-->A "dist" folder, short for "distribution," is a directory typically found in software development 
projects. It contains the files and assets that are intended for distribution or deployment in a 
production environment. These files are often optimized, compiled, or bundled versions of the source code and assets.

The "dist" folder typically includes:
Minified or compiled code files (e.g., JavaScript, CSS) to reduce file size and improve performance.
Production-ready HTML files.
Images, fonts, or other static assets required for the application to run.
Configuration files and dependencies required for the deployed application.

Developers create the "dist" folder as part of the build process to prepare the application 
for deployment. It helps separate the development and production environments, 
ensuring that the deployed application is efficient and optimized for end-users.

13. what is browserLists?
--> browserslist is a configuration file or setting used in web development tools like Autoprefixer,
 Babel, and stylelint to specify which web browsers and their versions you want to support
  when writing CSS or JavaScript code. It allows you to define a list of target browsers for your
 project, and tools that use browserslist will automatically generate code that is compatible with 
 those specified browsers, including adding necessary vendor prefixes and transpiling JavaScript features.

For example, by setting a browserslist configuration to support "last 2 versions" of major browsers,
 your development tools can ensure that your CSS and JavaScript are compatible with 
 recent browser releases, helping to maintain cross-browser compatibility for your web applications.

14. diff bundlers?
--> Webpack:
Purpose: Highly configurable bundler used for managing dependencies, optimizing assets, and preparing
 them for production.
Key Features: Supports various loaders and plugins for tasks like transpilation, 
minification, code splitting, and more.
Use Cases: Well-suited for complex projects with advanced configuration needs.

Parcel:
Purpose: Zero-config bundler designed for simplicity and ease of use.
Key Features: Requires minimal configuration, automatically handles dependencies, 
and provides a built-in development server.
Use Cases: Great for quick prototyping, small to medium-sized projects,
 or when you prefer a minimal setup.

Rollup:
Purpose: JavaScript module bundler optimized for libraries and packages.
Key Features: Focuses on producing smaller, more efficient bundles, 
making it ideal for publishing libraries.
Use Cases: Best suited for building libraries or packages meant to be consumed by other developers.

Browserify:
Purpose: Bundles Node.js-style modules for use in the browser.
Key Features: Translates Node.js-style require() calls to browser-compatible code.
Use Cases: Initially popular for adapting server-side code for client-side use,
 but has been largely superseded by Webpack.

FuseBox:
Purpose: Fast, efficient bundler with features like JIT (Just-In-Time) compilation.
Key Features: Emphasizes speed and performance, includes a development server, 
and supports a wide range of plugins.
Use Cases: Well-suited for projects where fast build times are a critical consideration.
Brunch:

Purpose: An opinionated, simple, and fast bundler with a focus on configurability.
Key Features: Minimal configuration required, supports a wide range of plugins,
 and provides a built-in development server.
Use Cases: Projects where simplicity and speed of setup are valued.

15. ^ and ~
-->  (caret):
Allows changes in the minor and patch versions but locks the major version.
Example: ^1.2.3 allows any version from 1.2.3 up to but not including 2.0.0.

~ (tilde):
Allows changes in the patch version but locks the major and minor versions.
Example: ~1.2.3 allows any version from 1.2.3 up to but not including 1.3.0.

16. Script types in html?
-->JavaScript (default):
<script> tag without a specified type defaults to JavaScript.
Example: <script>console.log("Hello, World!");</script>

JavaScript with a specific version:
You can specify a version of JavaScript using the type attribute, like type="text/javascript".
Example: <script type="text/javascript">console.log("Hello, World!");</script>

Module scripts:
Introduced in HTML5, module scripts use type="module".
Enables the use of ES6 modules for better code organization and modularity.
Example: <script type="module" src="main.js"></script>